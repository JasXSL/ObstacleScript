// This is the main controller that handles all the ghost stuff as far as the level linkset goes

#define VT_STRIDE 4
#ifndef VIABLE_TRAPS // (str)trap, (int)directions, (vector)pos_offs, (rotation)rot_offs
	#define VIABLE_TRAPS (list)\
		"Slimetrap" + (TRAPDIR_NORTH|TRAPDIR_EAST|TRAPDIR_SOUTH|TRAPDIR_WEST) + <0,0,.87> + 0 + \
		"Ghosthand" + (TRAPDIR_DOWN) + <0,0,1.07> + 0 + \
		"SummoningCircle" + (TRAPDIR_DOWN) + <0,0,.66> + 0 + \
		"Echo" + (TRAPDIR_DOWN) + <0,0,.75> + 0 + \
		"Moths" + (TRAPDIR_DOWN) + <0,0,.75> + 0 + \
		"Oilslick" + (TRAPDIR_DOWN) + <0,0,.66> + 0 + \
		"Ghostslap" + (TRAPDIR_DOWN) + <0,0,1.04> + 0 + \
		"D20" + (TRAPDIR_DOWN) + <0,0,.04> + 0 + \
		"Wandtrap" + (TRAPDIR_DOWN) + <0,0,.59> + 0 + \
		"Voidzone" + (TRAPDIR_DOWN) + <0,0,.655> + 0 + \
		"Shocktrap" + (TRAPDIR_DOWN) + <0,0,.75> + 0 + \
		"CeilingBlob" + (TRAPDIR_UP) + <0,0,1.07> + 0
		
#endif
#ifndef MAX_TRAPS
	#define MAX_TRAPS 5
#endif
#ifndef TRAP_FREQ
	#define TRAP_FREQ 180
#endif

integer GHOST_TYPE;		// Cached from GhostHelper_Game
int EVIDENCE_TYPES;		// Cached from GhostHelper_Game
int AFFIXES;			// Cached from GhostHelper_Game
float ACTIVITY = 1.0;  // Generic multiplier for ghost interacts.
float LAST_EVENT;
float VAPE_ENDS;
integer BFL;
#define BFL_HUNTING 0x1
float LAST_HUNT;
key CAUGHT_PLAYER;  // We're waiting for a bondage seat for this player
float LAST_TRAP;


int HUNTS;
int GHOST_EVENTS;
int OBJ_INTERACTS;
int PL_INTERACTS;
list TRAPS;				// stores position vectors for trap placement. Traps cannot be placed within 5m of each other.

// Test if a position is visible to a player
integer isPosVisible( vector pos ){
    
    list players = getPlayers();
    integer i;
    for(; i < count(players); ++i ){
        
        list ray = llCastRay(pos, prPos(l2k(players, i)), RC_DEFAULT);
        if( l2i(ray, -1) < 1 )
            return TRUE;
        
    }
    return FALSE;
    
}

// Checks if a trap is too close to another
integer trapSpotFree( vector pos ){
	
	integer i;
	for(; i < count(TRAPS); ++i ){
		if( llVecDist(l2v(TRAPS, i), pos) < 5 )
			return FALSE;
	}
	return TRUE;
	
}

// Places a trap
/*
	asset : asset to place
	pOffs : asset relative position offset
	rOffs : asset relative rotation offset
	id : ghost UUID
	directions : directions we can place this trap in (use [<1,0,0>,<0,1,0>,<-1,0,0>,<0,-1,0>] for walls, <0,0,1> for ceiling, <0,0,-1> for floor)
	z : z height relative to the floor to cast the ray from. Generally you can use 1 here.
*/
vector placeTrap( string asset, vector pOffs, rotation rOffs, key id, list directions, float z ){
    
    vector pos = prPos(id);
    if( pos == ZERO_VECTOR )
        return pos;
        
    list ray = llCastRay(pos, pos-<0,0,10>, RC_DEFAULT);

    if( l2i(ray, -1) < 1 )
        return ZERO_VECTOR;
		
    vector basePos = l2v(ray, 1)+<0,0,z>;
    // RC_DATA_FLAGS + RC_GET_NORMAL
    vector axis = <0,0,1>;
    
    directions = llListRandomize(directions, 1);

	integer i;
    for(; i < count(directions); ++i ){
        
        vector dir = l2v(directions, i);
        ray = llCastRay(basePos, basePos + (dir*10), RC_DEFAULT + RC_DATA_FLAGS + RC_GET_NORMAL);
        
        vector normal = l2v(ray, 2);
        pos = l2v(ray, 1);
           
        if( l2i(ray, -1) == 1 && (normal.z < 0.1 || llFabs(dir.z) > 0) ){
            
            rotation r = llRotBetween(axis, normal);
            pos += pOffs*rOffs*r;

            if( !isPosVisible(pos) && trapSpotFree(pos) ){
                
                rotation rot = rOffs*r;
                Rezzer$rez( LINK_THIS, asset, pos, rot, "", "TRAP", TRUE );
                
                return pos;
                
            }
            
        }
        
    }
	
	return ZERO_VECTOR;
    
    
}


placeRandomTrap( int force ){

	
	
	list traps = llListRandomize(VIABLE_TRAPS, VT_STRIDE);
	integer i;
	for(; i < count(traps); i += VT_STRIDE ){

		list dirs;
		string trap = l2s(traps, i);
		integer d = l2i(traps, i+1);
		if( llGetInventoryType(trap) == INVENTORY_OBJECT ){
	
			if( d & TRAPDIR_UP ) dirs += <0,0,1>;
			if( d & TRAPDIR_DOWN ) dirs += <0,0,-1>;
			if( d & TRAPDIR_NORTH ) dirs += <1,0,0>;
			if( d & TRAPDIR_EAST ) dirs += <0,1,0>;
			if( d & TRAPDIR_SOUTH ) dirs += <-1,0,0>;
			if( d & TRAPDIR_WEST ) dirs += <0,-1,0>;
			
			vector placed = placeTrap(trap, l2v(traps, i+2), l2r(traps, i+3), GhostGet$ghost(), dirs, 1.0);
			if( placed != ZERO_VECTOR ){
				
				if( force )
					llOwnerSay("Placed trap" + trap);
				LAST_TRAP = llGetTime();
				TRAPS += placed;
				return;
				
			}		
		
		}
		else if( force )
			llOwnerSay("Trap not in inv: "+trap);
	
	}
	
}


// Gets distance to the nearest player, reqLos is line of sight:
// 0 = no LOS req
// 1 = LOS req
// 2 = LOS and looking towards the ghost
float gnptgd( int reqLos ){
    
    vector ghost = prPos(GhostGet$ghost());
    float dist = -1;
    forPlayer( t, idx, pl )
        
		int plIdx = findPdata(pl);
        vector pp = prPos(pl);
        float d = llVecDist(ghost, pp);
        if( (dist < 0 || d < dist) && !isPlayerDead(plIdx) && ~plIdx ){
            
            list ray;
            if( reqLos )
                ray = llCastRay(ghost+<0,0,1>, pp+<0,0,1>, RC_DEFAULT);
            
            prAngX(pl, ang);
            if( reqLos == 2 && llFabs(ang) < PI_BY_TWO )
                ray = [];    
            
            if( l2i(ray, -1) == 0 )
                dist = d;

        }
    
    end
    return dist;
    
}
#define getNearestGhostPlayerDistance( reqLos ) gnptgd( reqLos )


int hasActiveToolNearby( int tool, float range ){
	
	list nodes = llJson2List(idbGetByIndex(idbTable$NODES, idbTable$NODES$GRMARKERS));
	
	forTool( idx, uuid, t )
		if( (int)j(t, TOOL_TYPE) == tool && (int)j(t, TOOL_DATA) ){
			
			vector tpos = prPos(uuid);
			vector gpos = prPos(GhostGet$ghost());
			float dist = llVecDist(<tpos.x,tpos.y,0>, <gpos.x,gpos.y,0>);
			if( dist < range && llFabs(tpos.z-gpos.z) < 2.5 )
				return TRUE;
			
		}
	end
	
	return FALSE;
	
}

saveStats(){
	idbSetByIndex(idbTable$GHOST_BEHAVIOR, idbTable$GHOST_BEHAVIOR$STATS, mkarr(GHOST_EVENTS + OBJ_INTERACTS + PL_INTERACTS + HUNTS));
}

// Checks if we can start a hunt
// First step in the check hunt chain. Forwarding to GhostNodes
// Tools then forwards CTH to nodes that makes sure players are in the building
checkStartHunt(){

	// Can't start if we're already hunting or an event is active
	if( BFL&BFL_HUNTING || llGetTime() < LAST_EVENT )
		return;
    LAST_HUNT = llGetTime();
    raiseEvent(0, "CTH");

}
// Note: use checkStartHunt on start instead since it checks horny bat
toggleHunt( integer on ){


    float dur = 30+GhostGet$difficulty()*10*(llFrand(0.5)+.5);
	// Hunt just started
    if( on && ~BFL&BFL_HUNTING ){
        
        BFL = BFL|BFL_HUNTING;
        setTimeout("HUNT_END", dur);
        ++HUNTS;
		saveStats();
		
    }
	// Hunt just ended
    else if( !on && BFL&BFL_HUNTING ){
        
        BFL = BFL&~BFL_HUNTING;
        unsetTimer("HUNT_END");
        
    }
	// No change. Ignore
    else
        return;
		
	// Either state change
    
    int hunting = (BFL&BFL_HUNTING)>0;
	idbSetByIndex(idbTable$GHOST_BEHAVIOR, idbTable$GHOST_BEHAVIOR$HUNTING, hunting);
    Door$lock( "DO:EXT", hunting );
    if( BFL & BFL_HUNTING ){
        Door$setRotPerc( "DO:EXT", 0 );
        GhostRadio$garble( "*", TRUE );
    }
    else{
        GhostRadio$garble( "*", FALSE );
    }
	ComApi$hostApiEvt(GhostApiEvt$hunt, (BFL&BFL_HUNTING > 0));
    LAST_HUNT = llGetTime();
    Ghost$toggleHunt( hunting );
    GhostTool$toggleHunt( hunting, GhostGet$ghost() );
    Lamp$flicker( "*", hunting, dur );
    raiseEvent(0, "HUNT" + hunting);
    
}


#include "ObstacleScript/begin.lsl"

#ifdef DEBUG
onStateEntry()

	GHOST_TYPE = GhostGet$type();
	EVIDENCE_TYPES = GhostGet$evidence();
	AFFIXES = GhostGet$affixes();
	setInterval("TOUCH", 5);
	list t = VIABLE_TRAPS;
	integer i;
	for(; i < count(t); i += VT_STRIDE ){
		
		if( llGetInventoryType(l2s(t, i)) != INVENTORY_OBJECT ){
			llOwnerSay("Trap missing from inventory: "+l2s(t, i));
		}
		
	}
	
end
#endif

handleEvent( "#Game", 0 )
	str type = argStr(0);
	
	if( type == "FRONT_DOOR" ){
		setInterval("TOUCH", 5);
		setInterval("TRAP", 10);
		LAST_TRAP = llGetTime();
	}
	
	if( type == "GAMESTART" ){
		
		GHOST_TYPE = GhostGet$type();
		EVIDENCE_TYPES = GhostGet$evidence();
		AFFIXES = GhostGet$affixes();
		ACTIVITY = llFrand(.4)+.6;   // This is a shuffle multiplied against the ghost type's activity
		GHOST_EVENTS = OBJ_INTERACTS = PL_INTERACTS = HUNTS = 0;	// Reset stats
		VAPE_ENDS = 0;
		TRAPS = [];
		BFL = 0;
		idbSetByIndex(idbTable$GHOST_BEHAVIOR, idbTable$GHOST_BEHAVIOR$HUNTING, 0);
		saveStats();
		
	}
	else if( type == "START_HUNT" ){
		// Try to start a hunt checking things like crucifix, smudge etc
		checkStartHunt();
		
	}
	else if( type == "TOGGLE_HUNT" ){
		
        toggleHunt(argInt(1));
		
	}
	else if( type == "PLACE_TRAP" ){
		placeRandomTrap(TRUE);
	}
	else if( type == "DEBUG" ){
		str desc = prDesc(GhostGet$ghost());
		qd("PIGR" + (int)idbGetByIndex(idbTable$NODES, idbTable$NODES$PIGR) + "ANGER" + GhostGet$aggression(desc) + "INTERACT" + GhostGet$activity(desc) + "Nearest player" + getNearestGhostPlayerDistance(FALSE) + "Nearest LOS" + getNearestGhostPlayerDistance(TRUE));
	}
	
	
end

handleTimer( "TRAP" )
	
	float time = llGetTime();
	if( time-LAST_TRAP < TRAP_FREQ || count(TRAPS) >= MAX_TRAPS )
		return;
	
	// Significantly lower chance of placing in a ghost room
	if( GhostGet$inGhostRoom( prDesc(GhostGet$ghost()) ) && llFrand(1.0) < 0.02 ){
		return;
	}
	
	if( llFrand(1) < 0.5 ) // Roll a dice to place a trap
		return;
	
	placeRandomTrap(FALSE);

end


// Ghost interactions, hunt timer etc
handleTimer( "TOUCH" )
    
	// Interact every 5 when hunting
    if( BFL & BFL_HUNTING ){
		GhostInteractions$interact(FALSE);  
        return;
	}
	key ghost = GhostGet$ghost();
	str desc = prDesc(ghost);
    int difficulty = GhostGet$difficulty();
    float plDist = getNearestGhostPlayerDistance(0);
    float plDistLos = getNearestGhostPlayerDistance(1);

    // Get average arousal
	float avg;
	int tot;
    forPlayer(all, i, k)
		
	    if( ~llGetAgentInfo(k) & AGENT_SITTING ){
			int idx = findPdata(k);
            avg += getPlayerArousal(idx);
			++tot;
		}
		
    end
	
	float avgArousalPerc;
	if( tot )
		avgArousalPerc = avg/tot/100;
	
	
    float evtChance = 0.075+0.075*avgArousalPerc;
	if( llGetTime() < VAPE_ENDS )
		evtChance *= 3;
		
	if( GHOST_TYPE == GhostConst$type$succubus )
		evtChance *= 2; // Succubus has increased ghost event chance
		
	if( GHOST_TYPE == GhostConst$type$hantuwu ){
	
		evtChance *= 3; // GHOST BEHAVIOR - HANTUWU :: Ghost evt chance x3
		if( !hasActiveToolNearby(ToolsetConst$types$ghost$hots, 2) ) // can only ghost event when near a HOTS
			evtChance = 0;
	}
    	
    if( 
        llGetTime()-LAST_EVENT > 60 && // Min 60 sec between
        plDistLos > 0 && plDistLos < 5 && // Needs to be a player within 5m
        avgArousalPerc > 0.05 && // Average arousal needs to be above 5
        llFrand(1.0) < evtChance // 5% chance per tick
    ){
        
        GhostEvents$trigger( ghost );
        LAST_EVENT = llGetTime()+5;	// Adds 5 as a grace period. When onGhostEvent is received, this is updated with the end time of the event.
        ++GHOST_EVENTS;
		saveStats();
        return;
        
    }
    
        
    // 20 sec min time between hunts on pro, 40 on intermediate and 60 on novice
	float graceTime = 20+(3-difficulty)*20;
	if( graceTime < 30 )
		graceTime = 30;
	
    if( llGetTime()-LAST_HUNT > graceTime && llGetTime()-LAST_EVENT > 15 ){
        // Start hunting at 40 arousal. But small chance.
        
        // Ghost has a min thresh to hunt
        float thresh = 0.4;
        float offs = (float)GhostGet$aggression(desc)/100.0;
        thresh -= offs/4;   // The threshold is only affected by 1/4th, offs has more impact on chance
        
        float average = avgArousalPerc;
        average += offs; // Ghost aggression also increases average, adding a higher chance
           
        if( average > thresh && llFrand(1.0) < llPow(average,3)*.75 ){
            
            checkStartHunt();
            //qd("Attempting to trigger a hunt");
            return;
            
        }
        
    }
    
    float activity = 0.5*llPow(0.9, difficulty); // 10% less interactive per difficulty above easy
    activity *= ACTIVITY;   // Add randomness
    // Get activity from ghost, such as asking for a sign
    activity += GhostGet$activity( desc )/100.0;
	if( activity < 0.1 )
		activity = 0.1;
    
    // GHOST BEHAVIOR :: INUGAMI - Activity based on players in room
    if( GHOST_TYPE == GhostConst$type$inugami ){
        
        if( (int)idbGetByIndex(idbTable$NODES, idbTable$NODES$PIGR) ) // Players in ghost room
            activity *= 0.15;   // -85% activity if players are in the room
        else
            activity *= 1.5;    // +50% activity if players are not in the room
        
    }
	
    if( llFrand(1.0) > activity )
        return;
    
	
    GhostInteractions$interact(FALSE);   
    //qd("Sending interact"); 
    
end

handleTimer( "HUNT_END" )
    toggleHunt(FALSE);
end



onGhostForceHunt()
	checkStartHunt();
end

onGhostEvent( ghost, players, baseType, subType, dur )
	LAST_EVENT = llGetTime()+dur;
end



onGhostInteraction( ghost, asset, power )
    
    int level = 1+llFloor(llFrand(2));  // 2-3
    if( power ){
        
        level = 3;
        
        
        float plDistLos = getNearestGhostPlayerDistance(true);
        
        if( 
            EVIDENCE_TYPES & GhostConst$evidence$owometer && llFrand(1.0) < .5
        ) // 4-5
            ++level;
        
    }
    
    if( llGetAgentSize(asset) != ZERO_VECTOR ){
        ++PL_INTERACTS;
    }
    else{
        ++OBJ_INTERACTS;
    }
	saveStats();
	
    forPlayer( t, index, player )

        float arousal;
        if( player == asset )
            arousal = 2*((power>0)+1);
        else if( agentLookingAt( player, asset) ){
            
            vector as = llGetAgentSize(player);
            list ray = llCastRay(prPos(player)+<0,0,as.z*.2>, prPos(asset), RC_DEFAULT);
            if( l2i(ray, -1) < 1 || prRoot(l2k(ray, 0)) == asset )
                arousal = 2;
            
            // GHOST BEHAVIOR :: Powoltergeist - More arousal when witnessing a yeet
            if( GHOST_TYPE == GhostConst$type$powoltergeist )
                arousal *= 1.5;
            
        }
    
        if( arousal > 0 )
			raiseEvent(0, "AROUSE" + player + arousal);
        
    end
    
    float dur = 20-GhostGet$difficulty()*2;
    Owometer$addPoint( asset, level, dur );

end


// Ghost has caught a player.
onLevelCustomGhostCaught( ghost, player )
    
    toggleHunt(FALSE);
	list players = getPlayers();
    int pos = llListFindList(players, [(str)player]);
    if( pos == -1 ){
        return;
    }
    
    CAUGHT_PLAYER = idbGetByIndex(idbTable$HUDS, pos);
    Bondage$getFree();
    
end

onLevelCustomBondageFree( chair )
   
    if( CAUGHT_PLAYER == "" )
        return;
        
    Ghost$sendToChair( chair, CAUGHT_PLAYER, (!GhostGet$difficulty()) );
    
end

// Ghost successfully vaped
onLevelCustomGhostVaped()
	VAPE_ENDS = LAST_HUNT = llGetTime()+90+20*(3-GhostGet$difficulty());
end


handleEvent( "#Tools", 0 )
    
	// Final step of the hunt chain. Starts the actual hunt
    str type = argStr(0);
    if( type == "START_HUNT" ){
        toggleHunt(TRUE);
    }
	
end


#include "ObstacleScript/end.lsl"


